<!DOCTYPE html>
<html>
<head>
  <title>Test Realtime Error Handling</title>
</head>
<body>
  <h1>Realtime Error Handling Tests</h1>
  <div id="results"></div>
  
  <script>
    // Simulate the fixed error extraction logic
    function extractErrorMessage(error, status) {
      let msg = 'Unknown error';
      
      if (error) {
        if (error.message) {
          msg = error.message;
        } else if (error.details) {
          msg = error.details;
        } else if (error.error) {
          msg = error.error;
        } else if (typeof error === 'string') {
          msg = error;
        } else if (typeof error === 'object') {
          try {
            msg = JSON.stringify(error);
          } catch (e) {
            msg = 'Error object could not be serialized';
          }
        }
      } else if (status) {
        msg = `Channel status: ${status}`;
      }
      
      return msg;
    }
    
    // Test cases
    const tests = [
      { name: 'Undefined error', error: undefined, status: 'CHANNEL_ERROR', expected: 'Channel status: CHANNEL_ERROR' },
      { name: 'Null error', error: null, status: 'CLOSED', expected: 'Channel status: CLOSED' },
      { name: 'Error with message', error: { message: 'Connection timeout' }, status: null, expected: 'Connection timeout' },
      { name: 'Error with details', error: { details: 'Network failure' }, status: null, expected: 'Network failure' },
      { name: 'String error', error: 'WebSocket error', status: null, expected: 'WebSocket error' },
      { name: 'Empty object', error: {}, status: null, expected: '{}' },
      { name: 'Complex object', error: { code: 500, type: 'SERVER_ERROR' }, status: null, expected: '{"code":500,"type":"SERVER_ERROR"}' },
      { name: 'No error no status', error: null, status: null, expected: 'Unknown error' }
    ];
    
    const results = document.getElementById('results');
    let html = '<table border="1"><tr><th>Test</th><th>Expected</th><th>Got</th><th>Result</th></tr>';
    
    tests.forEach(test => {
      const result = extractErrorMessage(test.error, test.status);
      const pass = result === test.expected;
      const emoji = pass ? '✅' : '❌';
      
      html += `<tr>
        <td>${test.name}</td>
        <td>${test.expected}</td>
        <td>${result}</td>
        <td>${emoji} ${pass ? 'PASS' : 'FAIL'}</td>
      </tr>`;
    });
    
    html += '</table>';
    results.innerHTML = html;
    
    // Summary
    const passed = tests.filter(t => extractErrorMessage(t.error, t.status) === t.expected).length;
    const total = tests.length;
    results.innerHTML += `<p><strong>Results: ${passed}/${total} tests passed</strong></p>`;
    
    if (passed === total) {
      results.innerHTML += '<p style="color: green; font-size: 20px;">✅ All tests passed! Error handling is working correctly.</p>';
    } else {
      results.innerHTML += '<p style="color: red; font-size: 20px;">❌ Some tests failed. Review the implementation.</p>';
    }
  </script>
</body>
</html>
